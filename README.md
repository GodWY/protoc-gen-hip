# 自动生成代码介绍

> protoc-gen-mqant 是一款可以自动生成rpc服务注册和调用的工具，其基于mqant微服务框架作为构建模板，通过读取Protobuffer的message和serveice构建服务注册和调用

## 构建生成代码工具

1. 下载代码到本地
```git
   // go1.17前
    go get -u github.com/GodWY/protoc-gen-hip@latest
    go install github.com/GodWY/protoc-gen-hip
    // go1.17后
    go install  github.com/GodWY/protoc-gen-hip@latest
```
2. 验证
> protoc-gen-hip --version
> 
> protoc-gen-hip v1.0.6

总结: 下载代码目的是将二进制文件下载到gopath的bin文件下。
## 构建一个服务

1. 定义请求greeter.proto文件
```protobuf
syntax="proto3";
package account;

option go_package="pkg/gen/http/account";


message SendSmsCodeRQ {
   // @gotags: json:"phone_num"
   string PhoneNum = 1;
}

message SendSmsCodeRS {
}

message AccessLoginRQ {
   // @gotags: json:"phone_num"
   string PhoneNum = 1;
   // @gotags: json:"phone_code"
   string PhoneCode = 2;
}

message AccessLoginRS {
}

//@import:xxx.xxx.xxx @import:xxx.xxxx.xxxx
//@middle:xxx.Has()
//@root:/api/xx
service Account{
   //@method:POST @middle:xxx.Has()
   rpc SendSmsCode(SendSmsCodeRQ) returns (SendSmsCodeRS);
   //@method:POST
   rpc AccessLogin(AccessLoginRQ) returns (AccessLoginRS);
}
```
3. 执行构建代码

```shell
    protoc --plugin=protoc-gen-go=/Users/GodWY/go/bin/protoc-gen-go   --go_out=./  ./proto/examples/*.proto --experimental_allow_proto3_optional
    protoc --plugin=protoc-gen-mqant=protoc-gen-mqant  --proto_path=.  --mqant_out=./   ./proto/examples/*.proto ./proto/examples1/*.proto --experimental_allow_proto3_optional
```

3. 生成的代码

```go
// Code generated by protoc-gen-go-hip. DO NOT EDIT.
// versions:v1.2.0

package account

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
import (
   "net/http"
   "github.com/GodWY/gutil"
   "xxx.xxx.xxx"

   "github.com/gin-gonic/gin"
)

// generated http method
func registerAccountHttpHandler(srv *gin.Engine, srvs AccountHttpHandler) {
   group := srv.Group("/api/account", xxx.Has())
   group.POST("/v1/sendSmsCode", srvs.SendSmsCode, xxx.Has())
   group.POST("/v1/accessLogin", srvs.AccessLogin)
}

var TAccount Account

func RegisterAccountHttpHandler(srv *gin.Engine, srvs Account) {
   tmp := new(xxx_Account)
   registerAccountHttpHandler(srv, tmp)
   TAccount = srvs
}

type Account interface {
   SendSmsCode(ctx *gin.Context, in *SendSmsCodeRQ) (out *SendSmsCodeRS, err error)
   AccessLogin(ctx *gin.Context, in *AccessLoginRQ) (out *AccessLoginRS, err error)
}

// generated http handle
type AccountHttpHandler interface {
   SendSmsCode(ctx *gin.Context)
   AccessLogin(ctx *gin.Context)
}

type xxx_Account struct {
}

func (xx *xxx_Account) SendSmsCode(ctx *gin.Context) {
   req := &SendSmsCodeRQ{}
   if ok := ctx.Bind(req); ok != nil {
      detail := "bind request error"
      rt := gutil.RetFail(10000, detail)
      ctx.JSON(http.StatusOK, rt)
      return
   }
   rsp, err := TAccount.SendSmsCode(ctx, req)

   if err != nil {
      ctx.JSON(http.StatusOK, gutil.RetError(err))
      return
   }
   ctx.JSON(http.StatusOK, gutil.RetSuccess("success", rsp))
}

func (xx *xxx_Account) AccessLogin(ctx *gin.Context) {
   req := &AccessLoginRQ{}
   if ok := ctx.Bind(req); ok != nil {
      detail := "bind request error"
      rt := gutil.RetFail(10000, detail)
      ctx.JSON(http.StatusOK, rt)
      return
   }
   rsp, err := TAccount.AccessLogin(ctx, req)

   if err != nil {
      ctx.JSON(http.StatusOK, gutil.RetError(err))
      return
   }
   ctx.JSON(http.StatusOK, gutil.RetSuccess("success", rsp))
}

```
4. 特别注意 需要额外插件：
   GitHub - favadi/protoc-go-inject-tag: Inject custom tags to protobuf golang struct




5. 支持导入三方包，自定义中间件和自定义路由

> 所有的自定义代码都是通过注释读取的。

- 自定义组中间件
> 每一个service对应gin都是一个组，定义组路由只需要使用`@middle:`关键字即可，value是对应的方法
- 导入项目包
> 在service中定义 `@import` 可以连续定义多个导入包

- 定义接口请求

> 在每个rpc接口中,自定义请求方法 `@method` 即可目前支持GET，POST，ANY 不区分大小写

- 定义接口中间件
> 在接口注释中 `@middle` 即可定义自定义和gin中间件

- 如何自定义组路由

> 在service 定义`@root`即可

