# 自动生成代码介绍

> protoc-gen-mqant 是一款可以自动生成rpc服务注册和调用的工具，其基于mqant微服务框架作为构建模板，通过读取Protobuffer的message和serveice构建服务注册和调用

## 构建生成代码工具

1. 下载代码到本地
```git
   // go1.17前
    go get -u github.com/GodWY/protoc-gen-hip@latest
    go install github.com/GodWY/protoc-gen-hip
    // go1.17后
    go install  github.com/GodWY/protoc-gen-hip@latest
```
2. 验证
> protoc-gen-hip --version
> 
> protoc-gen-hip v1.0.6

总结: 下载代码目的是将二进制文件下载到gopath的bin文件下。
## 构建一个服务

1. 定义请求greeter.proto文件
```protobuf
syntax = "proto3";
package mangersrv;
option go_package = "pkg/gen/managersrv";
message EditUserInfoRQ{
    // Id 分配的唯一id @gotags: form:"id"
    int32 Id = 1;
    // 邮箱  @gotags: form:"email"
    string Email = 2;
    // @gotags: form:"nickname"
    string NickName = 3;
    // @gotags: form:"note"
    string Note = 4;
    // @gotags: form:"password"
    string Password = 5;
    // @gotags: form:"status"
    int32 Status = 6;
    //  @gotags: form:"username"
    string Username = 7;
}

message EditUserInfoRS{
    // @gotags: form:"code"
    int32 Code = 1;
    // @gotags: form:"message"
    string Message = 2;
}

// DeleteUserRQ 删除用户
message DeleteUserRQ{
    // Id 分配的唯一id @gotags: form:"id"
    int32 Id = 1;
    }
    message DeleteUserRS{
    // @gotags: form:"code"
    int32 Code = 1;
    // @gotags: form:"message"
    string Message = 2;
}


service UserSrv{
    // @method:POST
    rpc EditUser(EditUserInfoRQ)returns(EditUserInfoRS);
    // @method:POST
    rpc DeleteUser(DeleteUserRQ)returns(DeleteUserRS);
}
```
3. 执行构建代码

```shell
    protoc --plugin=protoc-gen-go=/Users/GodWY/go/bin/protoc-gen-go   --go_out=./  ./proto/examples/*.proto --experimental_allow_proto3_optional
    protoc --plugin=protoc-gen-mqant=protoc-gen-mqant  --proto_path=.  --mqant_out=./   ./proto/examples/*.proto ./proto/examples1/*.proto --experimental_allow_proto3_optional
```

3. 生成的代码

```go
// Code generated by protoc-gen-go-hi. DO NOT EDIT.
// versions:

package managersrv

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// generated http method
func registerUserSrvHttpHandler(srv *gin.Engine, srvs UserSrvHttpHandler) {
	group := srv.Group("usersrv")
	group.POST("/api/v1/edituser", srvs.EditUser)
	group.POST("/api/v1/deleteuser", srvs.DeleteUser)
}

var TUserSrv UserSrv

func RegisterUserSrvHttpHandler(srv *gin.Engine, srvs UserSrv) {
	tmp := new(xxx_UserSrv)
	registerUserSrvHttpHandler(srv, tmp)
	TUserSrv = srvs
}

type UserSrv interface {
	EditUser(ctx *gin.Context, in *EditUserInfoRQ) (out *EditUserInfoRS, err error)
	DeleteUser(ctx *gin.Context, in *DeleteUserRQ) (out *DeleteUserRS, err error)
}

// generated http handle
type UserSrvHttpHandler interface {
	EditUser(ctx *gin.Context)
	DeleteUser(ctx *gin.Context)
}

type xxx_UserSrv struct {
}

func (xx *xxx_UserSrv) EditUser(ctx *gin.Context) {
	req := &EditUserInfoRQ{}
	if ok := ctx.Bind(req); ok != nil {
		ctx.JSON(http.StatusOK, "bind error")
		return
	}
	rsp, err := TUserSrv.EditUser(ctx, req)
	if err != nil {
		ctx.JSON(http.StatusOK, err.Error())
		return
	}
	ctx.JSON(http.StatusOK, rsp)
}

func (xx *xxx_UserSrv) DeleteUser(ctx *gin.Context) {
	req := &DeleteUserRQ{}
	if ok := ctx.Bind(req); ok != nil {
		ctx.JSON(http.StatusOK, "bind error")
		return
	}
	rsp, err := TUserSrv.DeleteUser(ctx, req)
	if err != nil {
		ctx.JSON(http.StatusOK, err.Error())
		return
	}
	ctx.JSON(http.StatusOK, rsp)
}
```
4. 特别注意 需要额外插件：
   GitHub - favadi/protoc-go-inject-tag: Inject custom tags to protobuf golang struct



