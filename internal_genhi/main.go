package internal_genhi

import (
	"fmt"
	"github.com/GodWY/protoc-gen-hip/version"
	"go/ast"
	"go/parser"
	"go/token"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/proto"
	"strings"
	"unicode"
	"unicode/utf8"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"

	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

// SupportedFeatures reports the set of supported protobuf language features.
var SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

// GenerateFile generates the contents of a .pb.go file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	return generateFile(gen, file, false)
}

func genImport(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, imp protoreflect.FileImport) {
	impFile, ok := gen.FilesByPath[imp.Path()]
	if !ok {
		return
	}
	if impFile.GoImportPath == f.GoImportPath {
		// Don't generate imports or aliases for types in the same Go package.
		return
	}
	// Generate imports for all non-weak dependencies, even if they are not
	// referenced, because other code and tools depend on having the
	// full transitive closure of protocol buffer types in the binary.
	if !imp.IsWeak {
		g.Import(impFile.GoImportPath)
	}
	if !imp.IsPublic {
		return
	}

	// Generate public imports by generating the imported file, parsing it,
	// and extracting every symbol that should receive a forwarding declaration.
	impGen := GenerateFile(gen, impFile)
	impGen.Skip()
	b, err := impGen.Content()
	if err != nil {
		gen.Error(err)
		return
	}
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", b, parser.ParseComments)
	if err != nil {
		gen.Error(err)
		return
	}
	genForward := func(tok token.Token, name string, expr ast.Expr) {
		// Don't import unexported symbols.
		r, _ := utf8.DecodeRuneInString(name)
		if !unicode.IsUpper(r) {
			return
		}
		// Don't import the FileDescriptor.
		if name == impFile.GoDescriptorIdent.GoName {
			return
		}
		// Don't import decls referencing a symbol defined in another package.
		// i.e., don't import decls which are themselves public imports:
		//
		//	type T = somepackage.T
		if _, ok := expr.(*ast.SelectorExpr); ok {
			return
		}
		g.P(tok, " ", name, " = ", impFile.GoImportPath.Ident(name))
	}
	g.P("// Symbols defined in public import of ", imp.Path(), ".")
	g.P()
	for _, decl := range astFile.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range decl.Specs {
				switch spec := spec.(type) {
				case *ast.TypeSpec:
					genForward(decl.Tok, spec.Name.Name, spec.Type)
				case *ast.ValueSpec:
					for i, name := range spec.Names {
						var expr ast.Expr
						if i < len(spec.Values) {
							expr = spec.Values[i]
						}
						genForward(decl.Tok, name.Name, expr)
					}
				case *ast.ImportSpec:
				default:
					panic(fmt.Sprintf("can't generate forward for spec type %T", spec))
				}
			}
		}
	}
	g.P()
}

// generateFile generates a _http.pb.go file containing kratos errors definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File, omitempty bool) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_http.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	f := newFileInfo(file)
	g.P("// Code generated by protoc-gen-go-hip. DO NOT EDIT.")
	g.P("// versions:", version.String())
	for i, imps := 0, f.Desc.Imports(); i < imps.Len(); i++ {
		genImport(gen, g, f, imps.Get(i))
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	generateFileContent(gen, file, g, omitempty)
	return g
}

// generateFileContent generates the kratos errors definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) {
	if len(file.Services) == 0 {
		return
	}
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the mqant package it is being compiled against.")
	g.P("import (")
	g.P(`"net/http"`)
	g.P(`"github.com/GodWY/gutil"`)
	paths := genImportService(gen, file, g, omitempty)
	for _, path := range paths {
		g.P(`"`, path, `"`)
	}
	g.P()
	g.P(`"github.com/gin-gonic/gin"`)
	//g.P(`"github.com/GodWY/hip/service"`)
	g.P(")")

	// 自动生成注册gin的何种方法
	for _, service := range file.Services {
		// 服务的注释
		serviceComments := string(service.Comments.Leading)
		// 获取服务组的middleWare
		var commentsArr = []string{}
		if strings.Contains(serviceComments, "@") {
			// middleWares = parserComment(serviceComments)
			commentsArr = strings.Split(serviceComments, "@")
		}
		si := parserComment(commentsArr)
		if si.ProjectUri == "" {
			si.ProjectUri = "/api"
		}
		g.P("// generated http method")
		g.P("func register", service.GoName, "HttpHandler(srv *gin.Engine, srvs ", service.GoName, "HttpHandler) {")
		if len(si.MiddleWire) > 0 {
			g.P(`   group := srv.Group("`, si.ProjectUri, "/"+strings.ToLower(service.GoName), `" ,`, si.MiddleWire, ")")
		} else {
			g.P(`   group := srv.Group("`, si.ProjectUri, "/"+strings.ToLower(service.GoName), `" )`)
		}
		// 获取option 下定义的api参数
		restfulApis := ReadServiceOptions(g, service)
		for _, value := range service.Methods {
			restfulApi := &RestfulAPI{}
			for _, ra := range restfulApis {
				if ra.Method == value.GoName {
					restfulApi = ra
				}
			}
			a := string(value.Comments.Leading)
			method, middleWares := hasPathPrefix(a)
			methods := "/v1/" + strings.Trim(method, "\r\n")
			prefix := value.GoName[0:1]
			last := value.GoName[1:]
			x := strings.ToLower(prefix)
			path := fmt.Sprintf("%v%v", x, last)
			if restfulApi.RequestMethod != "" {
				methods = restfulApi.RequestMethod
			}
			if restfulApi.Url != "" {
				path = restfulApi.Url
			}

			if len(middleWares) > 0 {
				// 拼接middle
				var valuemiddleWares string
				for i := 0; i < len(middleWares); i++ {
					m := strings.Trim(middleWares[i], "\r\n")
					valuemiddleWares = valuemiddleWares + m + ","
				}

				g.P("group.", methods, `("`, path, `"`, ", "+valuemiddleWares, ` srvs.`, value.GoName, ")")
			} else {
				g.P("group.", methods, `("`, path, `", srvs.`, value.GoName, ")")
			}

		}
		g.P("}")
		g.P()
	}

	// 自动生成服务调用接口
	for _, service := range file.Services {
		g.P("var T", service.GoName, " ", service.GoName)
		g.P()
		g.P("func Register", service.GoName, "HttpHandler(srv *gin.Engine,", "srvs ", service.GoName, ") {")
		g.P("  tmp := new(", "xxx_", service.GoName, ")")
		g.P("  register", service.GoName, "HttpHandler(srv, tmp)")
		g.P("  T", service.GoName, "=srvs")
		g.P("}")
		g.P()
		// 注册类型
		g.P("type ", service.GoName, " interface {")
		genService(gen, file, g, service, omitempty)
		g.P(" }")
	}
	g.P("// generated http handle")

	// 生成方法接口
	for _, service := range file.Services {
		g.P("type ", service.GoName, "HttpHandler", " interface {")
		genHttpService(gen, file, g, service, omitempty)
		g.P(" }")
		g.P()
	}

	// 生成对象
	// genHttpService implents
	for _, service := range file.Services {
		g.P("type ", "xxx_", service.GoName, " struct {")
		g.P("}")
		g.P()
		genXService(gen, file, g, service, omitempty)
		g.P()
	}

}

// hasMiddleware 判断注释里是否有middleware
// hasPathPrefix 获取注释数据
func hasPathPrefix(comm string) (method string, middlewares []string) {
	xx := strings.Split(comm, "@")
	method = ""
	middlewares = []string{}
	for _, xx := range xx {
		tags := strings.Split(xx, ":")
		if len(tags) > 2 {
			continue
		}
		tag := strings.TrimSpace(tags[0])
		switch tag {
		case "method":
			// 这是gin的方法, 全部大写
			method = strings.TrimSpace(strings.ToUpper(tags[1]))
			method = httpMethod(method)
		case "middle":
			middlewares = append(middlewares, tags[1:]...)
		}
	}
	return
}

func genXService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}

	for _, value := range service.Methods {
		g.P("func (xx *xxx_", service.GoName, ")", value.GoName, "(ctx *gin.Context)", "{")
		g.P("  req := &", value.Input.GoIdent, "{}")
		g.P("  if ok := ctx.ShouldBind(req); ok != nil {")
		g.P(`detail:= "bind request error"`)
		g.P("rt:=gutil.RetFail(10000,detail)")
		g.P(` 	  ctx.JSON(http.StatusOK, rt)`)
		g.P("     return")
		g.P("   }")
		g.P("   rsp, err := ", "T", service.GoName, ".", value.GoName, "(ctx,req)")
		g.P("")
		g.P("   if err != nil {")
		g.P("	  ctx.JSON(http.StatusOK, gutil.RetError(err))")
		g.P("     return")
		g.P("    }")
		g.P(` ctx.JSON(http.StatusOK, gutil.RetSuccess("success",rsp))`)
		g.P("}")
		g.P()
	}
}

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	for _, value := range service.Methods {
		g.P(value.GoName, "(ctx *gin.Context,in ", "*", value.Input.GoIdent, ")", "(out ", "*", value.Output.GoIdent, ",err error", " )")
	}
}

func genHttpService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	for _, value := range service.Methods {

		g.P(value.GoName, "(ctx ", "*", "gin.Context", ")")
	}
}

// RestfulAPI 定义方法
type RestfulAPI struct {
	// 请求方法。 目前支持GET，POST，ANY
	RequestMethod string
	// 自定义的路径
	Url string
	// api方法
	Method       string
	body         string
	responseBody string
}

// ReadServiceOptions 读取服务的option
func ReadServiceOptions(g *protogen.GeneratedFile, service *protogen.Service) []*RestfulAPI {
	//ra := &RestfulAPI{}
	rp := make([]*RestfulAPI, 0, len(service.Methods))
	for _, method := range service.Methods {
		rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
		if rule != nil && ok {
			for _, bind := range rule.AdditionalBindings {
				rp = append(rp, buildHTTPRule(g, method, bind))
			}
			rp = append(rp, buildHTTPRule(g, method, rule))
		}
	}
	return rp
}
func buildHTTPRule(g *protogen.GeneratedFile, m *protogen.Method, rule *annotations.HttpRule) *RestfulAPI {
	var (
		path         string
		method       string
		body         string
		responseBody string
	)
	switch pattern := rule.Pattern.(type) {
	case *annotations.HttpRule_Get:
		path = pattern.Get
		method = "GET"
	case *annotations.HttpRule_Put:
		path = pattern.Put
		method = "PUT"
	case *annotations.HttpRule_Post:
		path = pattern.Post
		method = "POST"
	case *annotations.HttpRule_Delete:
		path = pattern.Delete
		method = "DELETE"
	case *annotations.HttpRule_Patch:
		path = pattern.Patch
		method = "PATCH"
	case *annotations.HttpRule_Custom:
		path = pattern.Custom.Path
		method = pattern.Custom.Kind
	}
	body = rule.Body
	responseBody = rule.ResponseBody

	return &RestfulAPI{
		RequestMethod: method,
		Url:           path,
		Method:        m.GoName,
		body:          body,
		responseBody:  responseBody,
	}
}

// genImportService 读取本服务导入的包
func genImportService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) []string {
	// 读取导入的包
	importPath := []string{}
	for _, v := range file.Services {
		// 读取注释
		serviceComments := string(v.Comments.Leading)
		if serviceComments == "" {
			continue
		}
		var commentsArr = []string{}
		if strings.Contains(serviceComments, "@") {
			// middleWares = parserComment(serviceComments)
			commentsArr = strings.Split(serviceComments, "@")
		}
		for _, c := range commentsArr {
			c = strings.TrimSpace(c)
			c = strings.TrimLeft(c, "\r\n")
			c = strings.TrimRight(c, "\r\n")
			if strings.HasPrefix(c, "import") {
				importPath = append(importPath, strings.Split(c, ":")[1])
				continue
			}
		}
	}
	return importPath
}

const deprecationComment = "// Deprecated: Do not use."

// ServiceInfo 服务的基本信息，包括组路由，中间件
type ServiceInfo struct {
	// 根路由
	ProjectUri string
	// 中间件
	MiddleWire string
	// 导包路径
	ImportPath []string
}

// parserComment 转化注释为字符串
func parserComment(comment []string) *ServiceInfo {
	si := &ServiceInfo{}
	var middleware string
	for _, c := range comment {
		c = strings.TrimSpace(c)
		c = strings.TrimLeft(c, "\r\n")
		c = strings.TrimRight(c, "\r\n")
		if strings.HasPrefix(c, "root") {
			si.ProjectUri = strings.Split(c, ":")[1]
			continue
		}
		if strings.HasPrefix(c, "middle") {
			middleware = strings.Split(c, ":")[1]
		}

	}
	si.MiddleWire = middleware
	return si

}

// httpMethod 获取gin的方法，目前只支持GET，POST
func httpMethod(method string) string {
	newMethod := "GET"
	switch method {
	case "GET", "POST":
		return method
	case "ANY":
		return "Any"
	}
	return newMethod
}
